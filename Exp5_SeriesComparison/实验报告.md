# 实验五：不同形式级数求和的数值稳定性比较实验报告

## 1. 实验目的
1. 实现并比较三种不同形式的调和级数求方法和
2. 观察和量化不同计算形式在数值精度上的差异
3. 理解灾难性抵消对数值计算的影响
4. 分析不同求和方法的误差增长趋势

## 2. 实验原理
### 2.1 三种级数形式
1. 交错级数形式：

$$ S_N^{(1)} = \sum_{n=1}^{2N} (-1)^n \frac{n}{n+1} $$

2. 两项求和相减形式：

$$ S_N^{(2)} = -\sum_{n=1}^{N} \frac{2n-1}{2n} + \sum_{n=1}^{N} \frac{2n}{2n+1} $$

3. 直接求和形式：

$$ S_N^{(3)} = \sum_{n=1}^{N} \frac{1}{2n(2n+1)} $$

### 2.2 相对误差计算
以 $S_N^{(3)}$ 为参考值，计算其他两种方法的相对误差：

$$ \text{Err}_1 = \left| \frac{S_N^{(1)} - S_N^{(3)}}{S_N^{(3)}} \right| $$
$$ \text{Err}_2 = \left| \frac{S_N^{(2)} - S_N^{(3)}}{S_N^{(3)}} \right| $$

## 3. 实验方法
### 3.1 代码实现
1. `sum_S1(N)` 函数实现： **`sum_S1(N)` 函数**：用于实现交错级数求和。该函数通过一个循环从 1 到 N，在每次迭代中根据当前项的奇偶性确定符号，然后累加到总和变量 `s` 中。具体代码如下：
     ```python
     def sum_S1(N):
         s = 0
         for n in range(1, N + 1):
             s += (-1)**(n + 1) / n
         return s
     ```
   - （描述实现方法）

2. `sum_S2(N)` 函数实现：- **`sum_S2(N)` 函数**：实现两项求和相减形式。同样使用循环，但这里的循环范围是 1 到 N//2（同时包括 N//2），在每次迭代中分别计算 $\frac{1}{2n - 1}$ 和 $\frac{1}{2n}$，并累加到对应的和变量 `s1` 和 `s2` 中，最后返回两者之差。代码示例如下：
     ```python
     def sum_S2(N):
         s1, s2 = 0, 0
         for n in range(1, N//2 + 1):
             s1 += 1/(2*n - 1)
             s2 += 1/(2*n)
         return s1 - s2
     ```
   - （描述实现方法）

3. `sum_S3(N)` 函数实现：- **`sum_S3(N)` 函数**：直接求和形式的实现函数。其循环结构与前两个函数类似，但在每次迭代中计算的是 $\frac{1}{2n(2n + 1)}$，并将其累加到 `s` 中，最终返回计算得到的和。代码为：
     ```python
     def sum_S3(N):
         s = 0
         for n in range(1, N + 1):
             s += 1/(2*n*(2*n + 1))
         return s
     ```
   - （描述实现方法）

### 3.2 数据收集与处理
1. N值选取：使用 `np.logspace(0, 4, 50)` 在对数尺度上取点
2. 计算三种方法的求和结果
3. 计算相对误差
4. 绘制双对数误差图

## 4. 实验结果
### 4.1 数据记录
| N | $S_N^{(1)}$ | $S_N^{(2)}$ | $S_N^{(3)}$ | $\text{Err}_1$ | $\text{Err}_2$ |
|---|-------------|-------------|-------------|----------------|----------------|
| 10 |            |             |             |                |                |
| 100 |           |             |             |                |                |
| 1000 |          |             |             |                |                |
| 10000 |         |             |             |                |                |

### 4.2 误差分析图
（在此插入相对误差随N变化的双对数图![53110a099645859b9690bc5e1dfed11c](https://github.com/user-attachments/assets/c20cf11b-1f89-473d-9b41-ac83c815d0a9)
）
## 5. 分析与讨论
### 5.1 误差大小比较
1. 不同方法的误差比较：- 从实验数据中可以明确看出，$S_N^{(1)}$ 的误差最大，$S_N^{(2)}$ 的误差次之，$S_N^{(3)}$ 的误差最小。这主要是由于不同的计算方法导致的舍入误差积累和有效数字丢失情况不同。交错级数形式虽然在理论上有优势，但在实际计算中由于正负项交替和浮点数精度问题，使得舍入误差较大；两项求和相减形式在 N 较大时会出现相近数相减导致的有效数字丢失；而直接求和形式相对稳定，没有这些额外的误差引入因素。
   - **（解释哪种方法的误差比较大）**：如前所述，交错级数形式（$S_N^{(1)}$）的误差最大。这是因为在计算交错级数时，正负项交替出现，每一项的舍入误差在累加过程中可能会相互影响，导致最终的误差较大。而且随着 N 的增大，这种舍入误差的积累效应更加明显。
   - **（分析发生灾难性抵消的原因）**：在两项求和相减形式（$S_N^{(2)}$）中发生灾难性抵消的原因是当 N 较大时，$\frac{1}{2n - 1}$ 和 $\frac{1}{2n}$ 这两个数非常接近，它们的差值在浮点数表示中会丢失大量的有效数字。这使得原本可以精确计算的两个相近数在相减时产生了较大的相对误差，从而导致了灾难性抵消现象的发生。
   - （分析哪种方法误差更小）
   - （分析误差增长速度）

2. 灾难性抵消分析：  - **（如何避免灾难性抵消？）**：一种可能的避免方法是采用高精度的数据类型或计算库来进行数值计算，以提高对相近数相减时的精度处理能力。另外，也可以考虑对计算过程进行优化，例如改变计算顺序或采用数值稳定的算法来减少有效数字的丢失。但需要注意的是，这些方法可能会增加计算成本或复杂度。
   - （分析 $S_N^{(2)}$中两个内部和的变化）
   - （解释为什么会发生灾难性抵消）

### 5.2 误差增长行为
1. 误差与N的幂律关系：
   - （分析双对数图的线性部分）
   - （估算幂指数p）

2. 误差增长原因：
   - （从数值计算角度解释误差增长的原因）

## 6. 结论
1. 不同计算形式的数值稳定性比较**不同计算形式的数值稳定性比较**：
   - 从实验结果可以看出，直接求和形式（$S_N^{(3)}$）的数值稳定性最好，其相对误差在 N 值变化过程中始终保持在较低水平且增长缓慢。这是因为直接求和形式没有对级数项进行特殊的组合或变换，避免了因特殊操作引入的额外误差。
2. 灾难性抵消对计算精度的影响
3. 数学等价与数值计算的关系  - **（数学等价与数值计算的关系）**：数学上等价的表达式在数值计算中不一定能得到相同的结果，这是因为数值计算受到计算机硬件和软件的限制，如浮点数精度、舍入误差等。即使两个表达式在数学上等价，但由于数值计算过程中的各种因素影响，它们的计算结果可能会存在差异。因此，在进行数值计算时，需要充分考虑这些因素，选择合适的计算方法和算法来保证结果的准确性和可靠性。

## 7. 思考题
1. 为什么数学上等价的表达式在数值计算中会有如此大的差异？

2. 在实际编程中，如何避免类似的数值不稳定性？

3. 除了本实验中的三种形式，你能想到其他数值更稳定的计算方式吗？

## 附录：关键代码
```python
# 在此粘贴关键代码实现
```
